---
title: 锁机制注入 bypass 雷池 WAF！
date: 2025-06-27 00:44:00 +0800
categories: [Web安全]
tags: [SQL注入, Bypass WAF, Web安全]
media_subpath: /
---

## 前言

在 SQL 注入的延时注入中，常见的函数有 `sleep()` 直接延时、`BENCHMARK()` 通过让数据库进行大量的计算而达到延时的效果、笛卡尔积、正则匹配等，但还有一个常常被忽略的函数，也就是 MySQL 中的锁机制。虽然早些年就已经出现过相关技术文章，但它的应用却几乎见不到，也没有文章对其机制和运用进行深入讲解，而且该函数也常常被 WAF 忽略导致延时。:contentReference[oaicite:1]{index=1}

## Mysql 锁机制介绍

### 函数介绍

`GET_LOCK()` 是 MySQL 提供的一个用户级锁函数，用于在应用层实现跨会话的锁机制：

```sql
GET_LOCK(str lock_name, int timeout)
```
**参数：**

lock_name（字符串）：锁名称（最大64字符，区分大小写）

timeout（整数）：等待超时时间（秒），0表示立即返回，负数表示无限等待（MySQL 5.7.5+）

**返回值：**

1：成功获取锁

0：获取锁超时（其他会话持有锁且未在指定时间内释放）

NULL：发生错误（如参数无效、内存不足等）

<br>

```sql
RELEASE_LOCK(str)
```
**参数：**

用于解开锁，str表示要解开的锁名
 
**返回值：**
 
1：成功释放，当前会话持有锁并成功释放
 
0：释放失败，当前会话不持有该锁
 
NULL：错误或锁不存在， 锁名称从未被获取

<br>

**示例：**
 
通过返回值1判断成功获取名为1的锁

![](assets/img/2025062701/0.png)

<br>

通过返回值1判断成功释放名为1的锁

![](assets/img/2025062701/1.png)

<br>

再次释放时，则为Null（锁不存在）

![](assets/img/2025062701/2.png)

### 核心特性
 
**命名锁机制：**
 
基于字符串名称的锁，不同锁名互不影响，例如：

 ```sql
GET_LOCK('test1', 10)
 
GET_LOCK('test2', 10)
```
 
他们直接由于锁名不同，所以互不影响

**会话级作用域：**
 
当一个会话成功获取了某个命名锁后，其他会话在尝试获取相同名称的锁时将会被阻塞，直到锁被释放或超时。
 
而在同一个会话内部，即使多次请求相同的锁，也不会造成阻塞，会直接返回成功，因为该会话已经持有该锁。

![](assets/img/2025062701/4.png)

**示例：**
 
会话1先通过GET_LOCK()函数获取了名为1的锁，返回结果为1表示获取成功

![](assets/img/2025062701/5.png)

会话2再次通过GET_LOCK()函数获取名为1的锁，但是名为1的锁以及被会话1占有，所以会话2直到超时5秒，结果为0表示获取失败

![](assets/img/2025062701/6.png)

**锁释放规则：**
 
显式释放：RELEASE_LOCK('lock_name')
 
隐式释放：会话终止（连接关闭）
 
时效释放：受wait_timeout 参数控制
 
不会随事务结束自动释放（与InnoDB行锁不同）

```sql
SHOW VARIABLES LIKE 'wait_timeout'
```
 
可以查看会话超时时间（秒），这里是2分钟

![](assets/img/2025062701/7.png)

```sql
SET SESSION wait_timeout = 600;
```
 
可以通过该函数来设置wait_timeout参数

![](assets/img/2025062701/8.png)

通过网上搜索发现wait_timeout参数的默认值是8小时，但是我的数据库默认就是2分钟，也没有看到官方的具体说明，可能是受到Mysql版本的影响。

## Web各类布局中的利用 
 
### 利用条件

刚刚讲完了Mysql锁的机制，那么要使用GET_LOCK()函数成功让目标数据库发现延迟，就需要具备以下两个条件：

1. 需要不同会话（只有不同会话的锁竞争才会导致延时）
 
2. 获取锁的会话具备长时效应（既会话或锁不被马上释放）

![](assets/img/2025062701/9.png)

### 短会话模式
 
**模式简介：**
 
每个HTTP请求都新建数据库连接，请求完成后立即关闭连接。无连接复用。
 
**使用规模：**
 
极少，主要存在于遗留系统或极低流量场景

![](assets/img/2025062701/10.png)

**利用可行性：**
 
这种情况下，大概率是无法造成锁等待，虽然每次用户的请求满足条件1：需要不同会话。但是无法满足条件2：获取锁的会话具备长时效应。也就是说当A会话获取完锁a，B会话还没来得及等待锁a，A会话就已经结束了，就自动释放锁，就无法达到锁等待的效果。
 
举一个最简单的例子，phpstudy中搭建的靶场sqli-labs就是如此（短会话模式）
 
这里拦截后大量发包，在一次性并发。

![](assets/img/2025062701/11.png)

通过数据库监听工具可以看到，当数据库还没来得及因为其他会话的锁造成等待，其他会话的锁就已经结束并关闭连接，自动释放锁了。所以不满足条件2：获取锁的会话具备长时效应。

![](assets/img/2025062701/12.png)

### 长会话模式
 
**模式简介：**
 
整个Web应用使用单个持久数据库连接，所有用户请求共享此连接。
 
**使用规模：**
 
较少，特定场景：金融交易系统、小型嵌入式应用，一些较老的cms也存在此情况

![](assets/img/2025062701/13.png)

**利用可行性：**
 
所有用户操作在同一个会话中，但条件1需要不同会话才会产生锁等待，所以不会发生锁等待，也就不能造成延时的效果

这里以MRCMS-3.1.2版本为例，他就是长会话模式

![](assets/img/2025062701/14.png)

通过数据库监听工具可以看到，无论进行多少次数据库操作他的thread_id一直都为994，尽管切换登录，替换用户凭证，ip等都还是thread_id为994且没有断开连接，那么就不满足条件1：需要不同会话（只有不同会话的锁竞争才会导致延时），也就不会导致锁等待，就不会造成延时的效果。

![](assets/img/2025062701/15.png)
