---
title: 锁机制注入 bypass 雷池 WAF！
date: 2025-06-27 00:44:00 +0800
categories: [Web安全]
tags: [SQL注入, Bypass WAF, Web安全]
media_subpath: /
---

## 前言

在 SQL 注入的延时注入中，常见的函数有 `sleep()` 直接延时、`BENCHMARK()` 通过让数据库进行大量的计算而达到延时的效果、笛卡尔积、正则匹配等，但还有一个常常被忽略的函数，也就是 MySQL 中的锁机制。虽然早些年就已经出现过相关技术文章，但它的应用却几乎见不到，也没有文章对其机制和运用进行深入讲解，而且该函数也常常被 WAF 忽略导致延时。:contentReference[oaicite:1]{index=1}

## Mysql 锁机制介绍

### 函数介绍

`GET_LOCK()` 是 MySQL 提供的一个用户级锁函数，用于在应用层实现跨会话的锁机制：

```sql
GET_LOCK(str lock_name, int timeout)
```
**参数：**

lock_name（字符串）：锁名称（最大64字符，区分大小写）

timeout（整数）：等待超时时间（秒），0表示立即返回，负数表示无限等待（MySQL 5.7.5+）

**返回值：**

1：成功获取锁

0：获取锁超时（其他会话持有锁且未在指定时间内释放）

NULL：发生错误（如参数无效、内存不足等）

<br>

```sql
RELEASE_LOCK(str)
```
**参数：**

用于解开锁，str表示要解开的锁名
 
**返回值：**
 
1：成功释放，当前会话持有锁并成功释放
 
0：释放失败，当前会话不持有该锁
 
NULL：错误或锁不存在， 锁名称从未被获取

<br>

**示例：**
 
通过返回值1判断成功获取名为1的锁

![](assets/img/2025062701/0.png)

<br>

通过返回值1判断成功释放名为1的锁

![](assets/img/2025062701/1.png)

<br>

再次释放时，则为Null（锁不存在）

![](assets/img/2025062701/2.png)

### 核心特性
 
**命名锁机制：**
 
基于字符串名称的锁，不同锁名互不影响，例如：

 ```sql
GET_LOCK('test1', 10)
 
GET_LOCK('test2', 10)
```
 
他们直接由于锁名不同，所以互不影响

**会话级作用域：**
 
当一个会话成功获取了某个命名锁后，其他会话在尝试获取相同名称的锁时将会被阻塞，直到锁被释放或超时。
 
而在同一个会话内部，即使多次请求相同的锁，也不会造成阻塞，会直接返回成功，因为该会话已经持有该锁。

![](assets/img/2025062701/3.png)

**示例：**
 
会话1先通过GET_LOCK()函数获取了名为1的锁，返回结果为1表示获取成功

![](assets/img/2025062701/4.png)

会话2再次通过GET_LOCK()函数获取名为1的锁，但是名为1的锁以及被会话1占有，所以会话2直到超时5秒，结果为0表示获取失败

![](assets/img/2025062701/5.png)

**锁释放规则：**
 
显式释放：RELEASE_LOCK('lock_name')
 
隐式释放：会话终止（连接关闭）
 
时效释放：受wait_timeout 参数控制
 
不会随事务结束自动释放（与InnoDB行锁不同）

```sql
SHOW VARIABLES LIKE 'wait_timeout'
```
 
可以查看会话超时时间（秒），这里是2分钟

![](assets/img/2025062701/6.png)

```sql
SET SESSION wait_timeout = 600;
```
 
可以通过该函数来设置wait_timeout参数

![](assets/img/2025062701/7.png)

通过网上搜索发现wait_timeout参数的默认值是8小时，但是我的数据库默认就是2分钟，也没有看到官方的具体说明，可能是受到Mysql版本的影响。

## Web各类布局中的利用 
 
### 利用条件
